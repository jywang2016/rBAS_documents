[
["index.html", "rBAS使用文档 前言 手册内容概述 夹带私货 致谢", " rBAS使用文档 王江宇 2018-08-18 前言 手册内容概述 本手册是为了大家更好地使用rBAS (Wang, Li, and Jiang 2018)包而撰写，内容如下: 第 1 章介绍了如何安装R语言的环境，来使用rBAS包。不用担心，R的语法很简单，各种功能是按照自身的需要安装各种packages，所以比matlab体积更小，入门时间成本也较低。哪怕你无意于R的学习，也可以看看本手册的原理篇(第 2 章)，应用篇(第4章)以及后续的更新计划(第 5 章)，来了解算法的原理，出现了哪些变种，以及有着什么样的工程应用。 第 2 章介绍了BAS算法以及在其基础上出现的各种改进算法的原理，当然，随着算法的不断改进和发展，这个文档还需要随之不断更新。 第 3 章讲述了如何在R中使用rBAS包调用收录的算法的对应函数，以及一些简单的案例（大部分是BAS相关文献中的算例和benchmark functions）。每一句出现的代码我都会尽我所能去注释，让大家了解每一步的意义，以及R的简单易用。我也希望，自己的语言能尽力通俗，对于其他工具的使用者来说。 第 4 章主要介绍的是BAS及变体算法在各种领域的应用，当然，少不了对应的案例描述和代码。可能有些涉及到各位作者的研究，不会做到完全的开源，但在李帅老师的组织下，我相信这会是最完善全面的BAS应用大全。 第 5 章讲述了rBAS包的开发和使用手册更新的计划。因为算法总是会不断地推陈出新，所以rBAS包也必须和目前的研究保持一致。如果你有好的想法，可以看此章的内容，然后把自己的建议传达给我们。 好了，冗长的章节介绍完毕。大家可以开始浏览正文了。 夹带私货 如果你对这本手册本身的撰写环境感兴趣的话，那我可能还要啰嗦两句。 第一句：照搬 Yihui 的一句话：我用了两个 R 包编译这本书，分别是 knitr (Xie 2015) 和 bookdown (Xie 2018)。 第二句：感谢 Yihui。嗯…，因为这个男人，R用户的读书笔记，文章，学位论文，个人网站等等都可以在R里面撰写或者开发。不得不感慨他的天才和对需求的把握。 致谢 感谢提倡者李帅老师，以及姜向远博士。他们是BAS的提出者，也在算法原理与改进上，给了我这个做暖通的门外汉以启发。 此外，还感谢李晓晓,王甜甜,莫小娟,阮月同学贡献自己的算法代码和应用案例，他(她)们改进了算法，并且让其应用部分变得更加丰富。 当然，还得感谢Yihui的bookdown。 老实讲，2018/07,也就是一个月以前，我刚开始用R编写这个算法，然后用在自己的建筑系统辨识研究中，没想到\\(\\dots\\) 所以，这个手册是比较仓促的产物，再加之自身关于优化算法理论水平较低，如果大家发现了本手册的各种问题，欢迎在QQ群(437958608)内留言，或者是在rBAS的 github上提出 issues。 总之，谢谢上述老师及同学，也谢谢未来给我提供问题或建议的同学，你们的帮助，让手册更加完善。 王江宇 2018/08/18 华中科技大学 参考文献 "],
["author.html", "作者简介 作者信息 用户界面里的作者信息", " 作者简介 作者信息 包作者 王江宇： BSAS算法，创建维护rBAS包。Github 李帅： 提出BAS以及BAS-WPT算法。个人主页 &amp; 谷歌学术 姜向远： 提出BAS以及BAS-WPT算法。 贡献者 李晓晓： 二阶BAS 王甜甜： 天牛群体优化算法BSO 阮月： Binary-BAS 莫小娟： 多杆机构优化问题 用户界面里的作者信息 在R里面输入以下代码： rBAS::run_BAS_App(theme = &#39;united&#39;) #从rBAS包中调用run_BAS_App函数，theme参数是用户界面的主题 上面的代码，与下述代码等价： library(rBAS) #加载rBAS包，此后调用函数就不需要 rBAS:: run_BAS_App(theme = &#39;united&#39;) #直接调用函数 可以看到rBAS的用户界面，里面有关于rBAS的作者信息。Rstudio-connect支持网页上嵌入shiny界面的骚操作，有待之后探究，所以用截图.来展示该作者信息界面。 图 .: 用户界面作者信息 "],
["install.html", "第 1 章 R以及rBAS安装 1.1 R安装 1.2 Rstudio安装 1.3 rBAS安装", " 第 1 章 R以及rBAS安装 R以及其集成开发环境(IDE)Rstudio加起来都不到200M，所以大家放心下载安装，不会是需要10+G的庞然大物。当然，matlab也是很好的科学计算软件，这里仅仅是说明安装的大小。 总体来说，R的安装十分简单，类似于把大象装进冰箱只需要三步。 1.1 R安装 Step1: 进入R的网站 https://www.r-project.org/ ，然后点击左上角Download底下的CRAN。 Step2: 选择并点击China底下的镜像网址，方便下载。然后点击Download R for windows，出现的界面右上角有install R for the first time，点击即可下载。 Step3: 安装，不需要各种复杂的配置，按照给定提示操作即可。 但是，打开R，你会发现是如图1.1这样过于简洁的界面。 图 1.1: R界面 这并不符合新手的操作和开发习惯。因此，你可能需要一个集成开发环境，最好是有函数、变量的提示，方便浏览代码和结果等等优势的软件。那么，我想你说的应该是 Rstudio。 1.2 Rstudio安装 Step1: 进入下载页面 https://www.rstudio.com/products/rstudio/download/ 。 Step2: 选择free版本的下载。 Step3: 安装，无需配置特别的环境变量等。 那么，打开Rstudio后，会看到如图1.2这样的界面。 图 1.2: Rstudio界面 左上角是撰写代码脚本的区域，左下角是结果输出的窗口。右下角的files可以查看工作路径下的文件，和matlab左侧的栏目是类似的；plots用于查看使用代码绘制的图像，packages可以用于安装CRAN上发布，或者是本地的packages，也就类似matlab的toolbox；help则是用来显示各个函数的帮助文档；Viewer则是用来预览R生成的交互图像(比如plotly绘制的图)，生成的网页(比如我现在正在使用bookdown包来写本手册，那就可以预览生成的gitbook电子书的内容)等等。右上角的Environment显示被加载进来的函数，变量等信息，和matlab的workspace是类似的。 剩下的和本手册无关，可以在后面的开发中慢慢了解。 1.3 rBAS安装 在Rstudio的Console框内输入: install.packages(&#39;devtools&#39;) 因为目前rBAS包还不在CRAN内，所以需要通过devtools包，来从github上安装。所以我们先在本地安装devtools包。如果觉得代码敲的累，那么有个更直观的方式，如图1.3： 图 1.3: devtools手动安装示意图 最后，有了devtools包，我们可以从github上安装rBAS包了。 #不加载devtools，只调用其中的函数 devtools::install_github(&quot;jywang2016/rBAS&quot;) 接下来，我们可以使用rBAS的函数了。 "],
["algorithm.html", "第 2 章 算法原理 2.1 BAS 2.2 BSAS 2.3 BAS-WPT", " 第 2 章 算法原理 本章讲述目前rBAS集成的三种算法的原理。如有错漏，还请指出。 2.1 BAS 关于BAS，主要的参考资料为姜向远博士和李帅老师在arXiv上的论文，BAS: beetle antennae search algorithm for optimization problems。而我是在知乎上看到一篇文章后，才开始复现BAS算法。 2.1.1 算法流程 1.随机生成方向向量，标准化 \\[\\begin{equation} \\overrightarrow{\\mathbf{b}}=\\frac{\\text{rnd}(n,1)}{\\|\\text{rnd}(n,1)\\|} \\tag{2.1} \\end{equation}\\] 其中，\\(n\\)是待优化参数的维度。 2.计算左右须的坐标 \\[\\begin{equation} \\begin{split} \\mathbf{x}_r&amp;=\\mathbf{x}^t+d^t\\overrightarrow{\\mathbf{b}} \\\\ \\mathbf{x}_l&amp;=\\mathbf{x}^t-d^t\\overrightarrow{\\mathbf{b}} \\end{split} \\tag{2.2} \\end{equation}\\] 其中，\\(\\mathbf{x}^t\\)为\\(t\\)时刻天牛的位置，\\(d^t\\)则是\\(t\\)时刻，质心到须的距离。 3.根据两须对应函数值，决定天牛下一时刻移动位置 \\[\\begin{equation} \\mathbf{x}^t=\\mathbf{x}^{t-1}+\\delta^t\\overrightarrow{\\mathbf{b}}\\text{sign}(f(\\mathbf{x}_r)-f(\\mathbf{x}_l)) \\tag{2.3} \\end{equation}\\] 其中，\\(\\delta^t\\)为t时刻的步长,\\(f\\)为待优化目标函数。 4.步长与搜索距离更新 \\[\\begin{align} d^t&amp;= \\eta_d d^{t-1}+d_0 \\tag{2.4}\\\\ \\delta^t&amp;=\\eta_{\\delta} \\delta^{t-1} \\tag{2.5} \\end{align}\\] 其中，\\(d_0\\)是人为设定的距离的常数，\\(\\eta_d\\)与\\(\\eta_\\delta\\)分别是搜索距离和步长的更新衰减系数。 为了避免参数过多，姜向远博士在BAS-WPT算法中是按照式(2.6)来更新搜索距离和步长的。其中，\\(c_2\\)是人为设定的常数。 \\[\\begin{align} \\delta^t&amp;=\\eta_{\\delta} \\delta^{t-1}\\\\ d^t &amp;= \\frac{\\delta^t}{c_2} \\tag{2.6} \\end{align}\\] 2.1.2 不足与改进 在对BAS算法的复现与案例应用中，我个人认为，其可能存在如下的缺点。 步长更新策略（反馈） 缺点：无论每一步得到的结果是否变得更优，步长总会衰减； 改进：带有反馈的步长更新，在无法找到更优的位置时，才进行步长的更新； 关键：反馈 初始步长选取（参数标准化） 缺点：对于多参数且量纲相差较大的问题，步长 \\(\\delta\\) 的初始值并不好选取； 改进：标准化参数后，再进行调节，这也是BAS-WPT的技巧所在； 关键：标准化 群体寻优 缺点：1只天牛在随机方向上搜索更优的位置，容易迷失； 改进：多只天牛寻优，设定的回合内无法找到更优位置，再考虑步长更新； 关键：群体智能 约束处理能力不足 缺点：在约束边界上优化目标突变问题的处理上表现不佳 改进：二阶BAS 关键：暂时没有能力归纳，有待学习二阶BAS 2.2 BSAS 在2.1.2节中提及，BAS可能在步长更新和群体寻优两个方面的策略上有一定的不足。因此，我比较莽撞地改出一个粗糙的算法，那就是所谓的BSAS，即beetle swarm antennae search。在BSAS: Beetle Swarm Antennae Search Algorithm for Optimization Problems中，我给出了更为详细的材料。至于具体和王甜甜同学的BSO，即beetle swarm optimization有何不同，我需要进一步研究她的论文材料。 2.2.1 与BAS不同之处 此部分没有公式，因为和BAS算法核心公式思路是一致的。而图2.1与图2.2描述了一种假设的寻优场景，能比较清晰地体现BSAS与BAS之间的不同。 图 2.1: BAS寻优过程示意 图 2.2: BSAS寻优过程示意 假定，天牛要找到图中最蓝的点。图2.1 中，天牛的起点在距离最优点较远处。由于位置更新只与时间有关，也就是每一步，天牛的步长都会缩减（为了可视化效果，天牛的大小我并没有缩放）。如果初始位置距离最优点较远，那在给定的步长缩减情况下，天牛只能在一个局部最优点处收敛。而图2.2中，每回合天牛会派出\\(k\\)只天牛在外试探，如果有更优的点，那么更新天牛位置。这样天牛可以更好地到达全局最优点。 2.2.2 不足与改进 虽然解决了步长更新和群体寻优的策略问题，但是还有两点并未解决。 初始步长选取（参数标准化） 缺点：对于多参数且量纲相差较大的问题，步长 \\(\\delta\\) 的初始值并不好选取； 改进：标准化参数后，再进行调节，这也是BAS-WPT的技巧所在； 约束处理能力不足 缺点：在约束边界上优化目标突变问题的处理上表现不佳 改进：二阶BAS 好的是，在rBAS 0.1.5中，我们吸收了BAS-WPT中参数标准化的想法，加入了BSAS-WPT算法，来解决步长调参的问题，并取得了一定的改进效果。 2.3 BAS-WPT 相比于2.1.1节中描绘的BAS， Beetle Antennae Search without Parameter Tuning (BAS-WPT) for Multi-objective Optimization一文给出了改进后的BAS是如何处理步长调节和约束问题抽象的。 2.3.1 与BAS不同之处 BAS-WPT的小尾巴without parameter tunning已经说明了两者之间的区别，即BAS-WPT是不需要进行参数调节的。当然，按照我现在的理解，是BAS-WPT一方面简化了每回合搜索距离(质心到须的距离)的更新，不需要再额外设定与调节诸如\\(d_0\\)，\\(\\eta_d\\)等参数，用户只需要按照式(2.6)来设置\\(c_2\\)便可；另一方面，参数标准化，让存在量级差异的参数之间不必再像BAS一样，共享一个你不知道该怎么设定的步长\\(\\delta^t\\)（步长过大，小的参数可能经常处于在边界的状态；步长过小，大的参数可能搜索范围达不到）。 那么上述两方面的优势归纳起来是什么呢，那就是你可以设置一个在 \\(1\\) 附近 \\(\\delta\\) ，然后设定一个衰减率 \\(\\eta_{\\delta}\\)，以及步长与搜索距离之比 \\(c_2\\)，那么你的天牛就不会出太大的岔子，并且方便调整调节。也就是说，WPT不是让你不用调参，而是减轻了调参的负担。 “不必就纠结归一化处理，之所以这么处理，仅仅是为了调参方便” — 姜向远 果然，偷懒催生了这一技巧的诞生。不过，我还得再次啰嗦一句标准化的好（是不是我没有接触这个领域，所以喜欢大惊小怪……）。我们在之后，压力容器约束问题(混合整型规划)中，可以看到，待优化参数存在量级差异时，标准化技巧下的步长会比原始的BAS步长设定要更加合理。 2.3.2 约束问题抽象形式 此外，BAS-WPT还为BAS引入了约束问题处理的手段。不过，这和我做模型预测控制时候看到的抽象方式是相同的。我觉得BAS的用户们应该都早已了解，此处就照本宣科。 2.3.2.1 约束问题一般形式 \\[\\begin{equation} \\begin{split} &amp; \\frac{\\text{Minimize}}{\\text{Maximize}} f(\\mathbf{x}) \\\\ s.t. &amp; g_j(\\mathbf{x})\\leq 0, j=1, \\cdots, K \\\\ &amp; x^\\text{max}_i \\leq x_i \\leq x^\\text{min}_i, i=1, \\cdots N \\end{split} \\tag{2.7} \\end{equation}\\] \\(g_j(\\mathbf{x})\\leq 0\\) 和 \\(x^\\text{max}_i \\leq x_i \\leq x^\\text{min}_i\\) 表示了参数本身的范围和更为精细具体的不等式约束控制。在rBAS包中，我们会有很直观和简便的方式，来设置这些约束。 2.3.2.2 惩罚函数 \\[\\begin{equation} F(\\mathbf{x})=f(\\mathbf{x})+\\lambda\\sum_{j=1}^{K}h_j(\\mathbf{x})g_j(\\mathbf{x}) \\tag{2.8} \\end{equation}\\] \\[\\begin{equation} h_j(\\mathbf{x}) = \\begin{cases} 1, &amp; g_j(\\mathbf{x})&gt;0 \\\\ 0, &amp; g_j(\\mathbf{x})\\leq0 \\end{cases} \\tag{2.9} \\end{equation}\\] 其中，式(2.8)中的\\(\\lambda\\)表示约束违背的惩罚因子，选取尽量大的正数。而后的\\(h_j(\\mathbf{x})\\)为Heaviside函数，即不等式约束满足时，该函数为0，反之为1。 2.3.3 不足与改进 约束处理能力不足 缺点：在约束边界上优化目标突变问题的处理上表现不佳 改进：二阶BAS 此处的不足，还需要考虑步长反馈和群体搜索的问题。不过，既然BSAS把姜博的WPT给窃来了，摇身变为了BSAS-WPT，那就不说上述两个问题了。等他日有闲，再去整合李晓晓同学的二阶BAS。 "],
["rBAS.html", "第 3 章 函数使用 3.1 BASoptim 3.2 BSASoptim 3.3 BSAS-WPT", " 第 3 章 函数使用 首先,加载rBAS包，然后在3.1节到3.3节中，我们详细讲述每个参数的含义。如果可能的话，我会加上调参时的经验（可能只对我的问题有用）。 library(rBAS) 打开网址，可以看到托管在github上的rBAS文档。大家可以通过Reference来访问里面所有函数的帮助文档，通过Changelog来看每次包的更新及bugs修复记录。 文档网页是由pkgdown包制作而成，logo由hexSticker包制作。 3.1 BASoptim 除了通过访问函数文档网站外，还可以在R中输入下面的命令，来查看文档。 help(BASoptim) 3.1.1 BASoptim参数说明 BASoptim函数(对应BAS算法)调用的格式如下： BASoptim(fn, init = NULL, lower = c(-6, 0), upper = c(-1, 2), constr = NULL, pen = 1e+05, d0 = 0.001, d1 = 3, eta_d = 0.95, l0 = 0,l1 = 0, eta_l = 0.95, step = 0.8, eta_step = 0.95, n = 200,steptol = 0.01, seed = NULL, trace = T ) 由于英文蹩脚，所以大家看起包自带的文档会比较吃力。因此，在此处给出中文说明。 已知条件：目标函数与约束 fn 待优化的目标函数 init 参数初始值，默认为NULL，即在上下限内随机选取，也可以自行指定 constr 不等式约束 lower/upper 上下限 pen 惩罚因子\\(\\lambda\\) BAS待调参数 d0 参见式(2.4)中所述的搜索距离（也就是质心到须的距离）参数，一个比较小的值，默认为0.001 d1 初始的搜索距离，默认为3 eta_d 搜索距离的衰减系数 l0/l1/eta_l 这一系列关于\\(l\\) 的参数，来源于BAS (Jiang Xiangyuan 2017a)论文中给出的matlab代码。其作用在于每回合位置更新时，产生一个随机抖动\\(x = x - step * dir * sign(fn(left) - fn(right)) + l *random(npars)\\) step/eta_step 步长以及步长的衰减率 steptol 停止更新的步长临界值 n 回合数或者迭代次数 其他 seed 给定随机种子，用来固定寻优结果。不同的种子，对结果的影响非常大。 trace 是否显示寻优过程信息 3.1.2 BASoptim简单案例 这里采用BAS (Jiang Xiangyuan 2017a)一文中给出的测试函数，即Michalewicz function 与 Goldstein-Price function。 3.1.2.1 Michalewicz function \\[ f(x)=\\sum_{i=1}^{d=2}sin(x_i)[sin(\\frac{ix_i^2}{\\pi})]^{20} \\] 图3.1为Michalewicz函数在给定的约束范围的三维示意图。可以看到，最小值在\\(x = -5,y = 1.5\\)的附近。 图 3.1: Michalewicz函数示意 我们先在R的脚本中构建出函数： # &lt;- 可以视作 = 即用等于号在此处也是可以的 mich &lt;- function(x){ y1 &lt;- -sin(x[1])*(sin((x[1]^2)/pi))^20 y2 &lt;- -sin(x[2])*(sin((2*x[2]^2)/pi))^20 return(y1+y2) } 然后利用rBAS包中的BASoptim函数求解： # 把BASoptim的寻优结果赋值给test test&lt;- BASoptim(fn = mich, lower = c(-6,0), upper = c(-1,2), seed = 1, n = 100,trace = FALSE) test$par ## [1] -4.964687 1.575415 test$value ## [1] -1.966817 可以看到，BAS在100个回合内找到了全局的最小值。非R用户可能对上下限的声明有点陌生，c(-6,0)中c()，其实是声明了一个向量，这也是R里面最基本的数据类型，和matlab里面的[-6 0]效果类似。整体看来，代码还是很简洁的。 3.1.2.2 Goldstein-Price function \\[\\begin{equation} \\begin{split} f({x})=&amp; [1+(x_1+x_2+1)^2(19-14x_1+3x_1^2-14x_2\\notag \\\\ &amp; +6x_1x_2+3x_2^2)][30+(2x_1-3X_2)^2(18-32x_1\\notag \\\\ &amp; +12x_1^2+48x_2-36x_1x_2+27x_2^2)]\\notag \\end{split} \\end{equation}\\] 图3.2为Goldstein-Price函数在给定的约束范围的三维示意图。可以看到，最小值在\\(x = -5,y = 1.5\\)的附近。图3.1与3.2均使用plotly绘制。 图 3.2: Michalewicz函数示意 函数构造： gold &lt;- function(x){ x1 &lt;- x[1] x2 &lt;- x[2] y1 &lt;- 1 + (x1 + x2 + 1)^2* (19 - 14*x1+3*x1^2 - 14*x2 + 6*x1*x2 + 3*x2^2) y2 &lt;- 30 + (2*x1 -3*x2)^2* (18 - 32*x1 + 12*x1^2+48*x2-36*x1*x2 + 27*x2^2) return(y1*y2) } 其中，x[1]表示向量x的第一个元素。举例，x = c(1,2)，那么x[1]等于1，x[2]等于2。索引从1开始，并不是从0开始（python和C++用户可能需要在此处注意）。 优化代码： test&lt;- BASoptim(fn = gold, lower = c(-2,-2), upper = c(2,2), seed = NULL, n = 100,trace = F) test$par ## [1] 0.001870855 -0.996496153 test$value ## [1] 3.004756 同样，结果也是给出了全局最优点（或在此附近，继续迭代下去，可能会有更精确更小的值）。 3.2 BSASoptim BSASoptim函数(对应BSAS算法)，在BAS的基础上，加入了步长反馈和群体策略。调用的格式如下： BSASoptim(fn, init = NULL, constr = NULL, lower = c(-6, 0), upper = c(-1, 2), k = 5, pen = 1e+05, d0 = 0.001, d1 = 3, eta_d = 0.95, l0 = 0, l1 = 0, eta_l = 0.95, step = 0.8, eta_step = 0.95,steptol = 0.01, n = 200, seed = NULL, trace = T, p_min = 0.2,p_step = 0.2, n_flag = 2) 3.2.1 BSASoptim参数说明 与BAS相比，BSAS在下面几处不同参数： k 每回合的外出试探的天牛数目，越多结果会越稳定(多次执行，结果更接近)，但是计算时长会相应增长。适当选取天牛数目，有助于避免随机的初始值和方向带来影响的同时，计算时长也可以接受。 p_min 当k只外出的天牛存在超过1只找到了更优的位置，也就是比当前的最佳值要更小。那是否需要更新到那k只天牛中最优的那一只所在的位置呢？经过一些尝试，我片面地认为，未必是每次都最佳，最后的位置一定最佳。因此，给定一个概率\\(p_{min}\\)。当有2只或以上的天牛找到更好的位置时，会在[0,1]间生成一个随机数，如果大于\\(p_{min}\\)，那么就选k只天牛里最优天牛作为下次的更新位置牛；如果小于\\(p_{min}\\)，那么就在找到了更好的位置的天牛里面，随机选出一只天牛，作为下次的更新位置。 p_step 想法与p_min类同，用于控制步长反馈策略。在k只天牛找不到更优位置时，算法认为是步长过大，下一回合天牛位置不更新，且会减小步长。反之，则更新天牛位置，并保持当前步长直至不能找到更优位置。那么，是否存在由于随机方向的原因，或者是k过小，导致在当前步长条件下，存在更优位置，但是找不到。这个时候，我们设置一个更新概率\\(p_{step}\\)，即在找不到更优的天牛位置下，步长有\\(p_{step}\\)概率不更新，继续寻找。 n_flag 为了防止设定过大的p_step，让数次产生的随机数都小于p_step，影响迭代的效率。我们给定了这个参数，默认为2，只要在同一个步长上的无效搜索(因为找不到更优位置而反复搜索)次数保持3次及以上，则会强制更新步长。 3.2.2 BSASoptim取值摸索 好吧，用中文说明都这么绕口，何况是我撰写的可怜的英文文档。有同学会问了，为什么要后面那几个概率和什么次数的参数，这不是画蛇添足吗？回答是，这几个参数来源于生活··· 我在做建筑阻容模型系统辨识时，每回合的寻优，都是在用龙哥库塔法求解一次常微分方程组(ODEs)。在我的问题规模下，每回合纯粹的R代码要耗费0.25s左右来求解一次这样的ODEs。也就是说，在求解目标函数上，程序耗费的时间就有\\(k*n*0.25\\)，还不算其他的计算开销。（换言之，用遗传算法，会带来更大的计算开销，因为每回合至少计算10*参数个数次的目标函数） 所以，我必须要结果较好的同时，尽量减少不必要的计算。因此，k不能太大，但是这又会在随机方向的影响下，错失一些优化的位置，那就需要p_step参数了。但是初始位置或者说中间位置附近的最优，不代表在这附近或方向上，有全局最优，所以我还需要p_min来保证，我有那么一丝可能，跳出每次都找最优，可是收敛结果与全局最优背离的怪圈。至于n_flag，是因为我之前设置了p_step为0.5，所以算法效率极低，几乎每个找不到更优的夜，这些天牛都悲伤地多做数次运行，所以我设置了这个参数。 还是需要强调，在我的问题里，这些参数起到了较好的效果。但是换成大家的研究，这些参数可能就是被害妄想症的产物了。有意思的是，我在默认参数下执行50次 Michalewicz 函数的寻优，效果并没有BASoptim好。但在RC模型辨识上，BSASoptim远好于BASoptim。 接下来就是这几个参数的调节的一些小技巧了。 设置k为1，那就是带步长反馈的BAS了 如果求解目标函数速度快，可以设置较大的k p_step设置为0，只要k只天牛找不到最优位置，步长就会更新；不存在不更新继续找的可能 p_step设置为1，那算法会在一个步长下一直执行，直到找到更优的位置，才会更新步长 p_min设置为0，在k只出去试探的天牛中找到了更优的位置时，那么当前时刻的天牛，总会选择这k只中最好的一只的位置来作为下一时刻的位置 p_min设置为1，下一时刻的位置是k只中更优天牛的位置的随机选择 为了求解效率，p_step会选择较小的值；p_min我也没有摸清楚个规律，但是在我的研究对象中，为0得到的结果在多次试验中，整体看来没有为较小值0.2好。 上述是我在自身研究方向上摸出的规律，可能问题的类型不同，需要做的取舍也不同。大家可以保持默认参数，然后进行符合自身情况的微调。更为详细的结果可以参见BSAS (Wang Jiangyu 2018)论文。 3.2.3 BSASoptim案例 3.2.3.1 Michalewicz function 不做过多的阐述对于此案例，可以参看3.1.2.1节。 library(rBAS) mich &lt;- function(x){ y1 &lt;- -sin(x[1])*(sin((x[1]^2)/pi))^20 y2 &lt;- -sin(x[2])*(sin((2*x[2]^2)/pi))^20 return(y1+y2) } result &lt;- BSASoptim(fn = mich, lower = c(-6,0), upper = c(-1,2), seed = 1, n = 100,k=5,step = 0.6, trace = FALSE) result$par ## [1] -4.970202 1.578791 result$value ## [1] -1.963534 3.2.3.2 Pressure Vessel function 使用BAS-WPT(Jiang Xiangyuan 2017b) 论文中压力容器优化函数来测试BSASoptim处理约束的能力。问题背景如下： \\[\\begin{align} \\text{minimize} f(\\mathbf{x}) = &amp;0.6224x_1x_3x_4+1.7781x_2x^2_3 \\notag\\\\ &amp;+3.1661x^2_1x_4 + 19.84x^2_1x_3 \\notag \\\\ s.t. ~~ g_1(\\mathbf{x}) = &amp; -x1 + 0.0193x_3 \\leq 0 \\notag \\\\ g_2(\\mathbf{x}) = &amp; -x_2 + 0.00954x_3 \\leq 0 \\notag \\\\ g_3(\\mathbf{x}) = &amp; -\\pi x^2_3x_4 -\\frac{4}{3}\\pi x^3_3 + 1296000 \\leq 0 \\notag \\\\ g_4(\\mathbf{x}) = &amp; x_4-240\\leq 0 \\notag \\\\ x_1 \\in&amp; \\{1,2,3,\\cdots,99\\}\\times0.0625 \\notag \\\\ x_2 \\in&amp; \\{1,2,3,\\cdots,99\\}\\times0.0625 \\notag \\\\ x_3 \\in&amp; [10,200] \\notag \\\\ x_4 \\in&amp; [10,200] \\notag \\\\ \\tag{3.1} \\end{align}\\] 构造一个列表，也就是list()。其中包含有2个函数，一个是我们的目标函数obj，一个是我们的不等式约束函数con。为了方便起见，我并没有写每一个函数的返回值，那么，R会自动返回计算的最后一个对象。比如，在obj函数中，是result变量（标量）被返回。而在con函数中，是由c()声明的向量被返回。 pressure_Vessel &lt;- list( obj = function(x){ x1 &lt;- floor(x[1])*0.0625 x2 &lt;- floor(x[2])*0.0625 x3 &lt;- x[3] x4 &lt;- x[4] result &lt;- 0.6224*x1*x3*x4 + 1.7781*x2*x3^2 + 3.1611*x1^2*x4 + 19.84*x1^2*x3 }, con = function(x){ x1 &lt;- floor(x[1])*0.0625 x2 &lt;- floor(x[2])*0.0625 x3 &lt;- x[3] x4 &lt;- x[4] c(#把所有的不等式约束，全部写为小于等于0的形式 0.0193*x3 - x1, 0.00954*x3 - x2, 750.0*1728.0 - pi*x3^2*x4 - 4/3*pi*x3^3 ) } ) 使用BSASoptim函数进行优化。需要注意的是,pressure_Vessel是一个列表，对于其中包含的元素，使用$符号进行访问。也可以使用[[符号，即 pressure_Vessel$obj 等价于 pressure_Vessel[[1]]。 result &lt;- BSASoptim(fn = pressure_Vessel$obj, k = 5, lower =c( 1, 1, 10, 10), upper = c(100, 100, 200, 200), constr = pressure_Vessel$con, n = 200, step = 100, d1 = 5, pen = 1e6, steptol = 1e-6, n_flag = 2, seed = 2,trace = FALSE) result$par ## [1] 14.92195 7.87620 43.51377 159.87104 result$value ## [1] 6309.406 可以看到结果与论文BAS-WPT(Jiang Xiangyuan 2017b)中TABLE 1给出的优化值还是有一定的差距。不过，这也让我意识到了，对于复杂的优化问题，调试其中的参数是个困难的活。歧路亡羊呀！ 好在，改进后的BSAS-WPT能够比较好地得到不逊于BAS-WPT(Jiang Xiangyuan 2017b)中的结果（在3.3.2节可以看到）。更多更优地结果，等待你去调参，如果你还有勇气的话。 3.2.3.3 Himmelblau function \\[\\begin{align} \\text{minimize} f(\\mathbf{x}) =&amp; 5.3578547x^2_3 +0.8356891x_1x_5\\notag \\\\ &amp;+ 37.29329x_1 - 40792.141 \\notag\\\\ s.t. ~~g_1(\\mathbf{x}) =&amp; 85.334407 + 0.0056858x_2x_5\\notag\\\\ &amp;+ 0.00026x_1x_4 - 0.0022053x_3x_5 \\notag\\\\ g_2(\\mathbf{x}) =&amp;80.51249 +0.0071317x_2x_5\\notag\\\\ &amp;+ 0.0029955x_1x_2 + 0.0021813x^2_3 \\notag\\\\ g_3(\\mathbf{x}) =&amp; 9.300961 +0.0047026x_3x_5\\notag\\\\ &amp;+ 0.0012547x_1x_3 + 0.0019085x_3x_4 \\notag\\\\ g_1(\\mathbf{x})\\in&amp;[0,92] \\notag\\\\ g_2(\\mathbf{x})\\in&amp;[90,110] \\notag\\\\ g_3(\\mathbf{x})\\in&amp;[20,25] \\notag\\\\ x_1\\in&amp;[78,102] \\notag\\\\ x_2\\in&amp;[33,45] \\notag\\\\ x_3\\in&amp;[27,45] \\notag\\\\ x_4\\in&amp;[27,45] \\notag\\\\ x_5\\in&amp;[27,45] \\notag\\\\ \\tag{3.2} \\end{align}\\] 构造优化目标函数和约束： himmelblau &lt;- list( obj = function(x){ x1 &lt;- x[1] x3 &lt;- x[3] x5 &lt;- x[5] result &lt;- 5.3578547*x3^2 + 0.8356891*x1*x5 + 37.29329*x[1] - 40792.141 }, con = function(x){ x1 &lt;- x[1] x2 &lt;- x[2] x3 &lt;- x[3] x4 &lt;- x[4] x5 &lt;- x[5] g1 &lt;- 85.334407 + 0.0056858*x2*x5 + 0.00026*x1*x4 - 0.0022053*x3*x5 g2 &lt;- 80.51249 + 0.0071317*x2*x5 + 0.0029955*x1*x2 + 0.0021813*x3^2 g3 &lt;- 9.300961 + 0.0047026*x3*x5 + 0.0012547*x1*x3 + 0.0019085*x3*x4 c( -g1, g1-92, 90-g2, g2 - 110, 20 - g3, g3 - 25 ) } ) 使用BSASoptim函数进行优化： result &lt;- BSASoptim(fn = himmelblau$obj, k = 5, lower =c(78,33,27,27,27), upper = c(102,45,45,45,45), constr = himmelblau$con, n = 200, step = 100, d1 = 10, pen = 1e6, steptol = 1e-6, n_flag = 2, seed = 11,trace = FALSE) result$par ## [1] 78.01565 33.00000 27.07409 45.00000 44.95878 result$value ## [1] -31024.17 这个结果，比BAS-WPT(Jiang Xiangyuan 2017b)中TABLE 2记载的结果都要好。但只要你愿意调差，嘿嘿，总有更好的。 3.3 BSAS-WPT 在进行BSAS-WPT参数讲解的这一部分前，我想问个问题。在式(3.1)和式(3.2)中，我们可以看到，有些\\(x_i\\)的约束范围较小，有的较大。比如，压力容器中，\\(x_1\\)和\\(x_2\\)就偏小，只是经过提取出0.0625，勉强能达到\\(x_3\\)和\\(x_4\\)的一半。那么，如果某些优化问题，其参数约束范围之间，相差了量级，该如何选择步长呢？这就是WPT的便捷之处了。 BSAS-WPT函数(对应BSAS-WPT算法)调用的格式如下： BSAS_WPT(fn, init = NULL, lower = c(-6, 0), upper = c(-1, 2), k = 5, constr = NULL, pen = 1e+05, c2 = 5, step = 1, eta_step = 0.95,steptol = 0.001, n = 200, seed = NULL, trace = T, p_min = 0.2,p_step = 0.2, n_flag = 2) 3.3.1 BSAS-WPT 参数说明 与BSAS相比，除去我人为略去的抖动部分，减少了搜索距离d相关的参数，这些用c2来替代。而初始步长step，我们可以设定为一个在1附近的数。由于算法先标准化了参数，然后根据式(2.3)在计算位置后，再根据上下限进行反标准化，而后导入目标函数。所以，你可以认为，BSAS中，把step变成一个\\(n\\)维的向量，假设\\(n\\)是参数个数，每个步长元素都根据参数的约束范围大小来设定，那么算法就会变成BSAS-WPT。 总之，现在要调节的参数，主要有2个，即c2和step。 3.3.2 BSAS-WPT 案例 我们使用和BSASoptim函数相同的例子来对比效果。但是，这些效果都是不固定的，即给定不同的参数，结果也会不同，所以不能根据一次结果评价算法的优劣。 3.3.2.1 Pressure Vessel function result &lt;- BSAS_WPT(fn = pressure_Vessel$obj, k = 8, lower =c( 1, 1, 10, 10), upper = c(100, 100, 200, 200), constr = pressure_Vessel$con, c2 = 10, n = 200, step = 2, seed = 1, n_flag = 3, trace = FALSE, steptol = 1e-6) result$par ## [1] 13.882270 7.434164 42.094999 176.932890 result$value ## [1] 6065.478 3.3.2.2 Himmelblau function result &lt;- BSAS_WPT(fn = himmelblau$obj, k = 10, lower =c(78,33,27,27,27), upper = c(102,45,45,45,45), constr = himmelblau$con, c2 = 5, n = 200, step = 1.6, pen = 1e5,trace = FALSE,seed = 11) ## ----step &lt; steptol---------stop the iteration------ result$par ## [1] 78.00000 33.00000 27.07176 45.00000 44.96713 result$value ## [1] -31025.47 BSAS-WPT没有做过多的参数调节，即可获得更畅快地优化体验。举例，在对Himmelblau函数进行优化时，我仅仅设定了随机种子seed，然后把step从1调到了2，看了看效果的变化。发现都不错，最后每隔0.1选取step，试探最好的效果在哪里，于是就成了上面的例子。 如果把这一套，放在BSASoptim函数上，对于复杂的优化问题，就成了一种折磨。 参考文献 "],
["examples.html", "第 4 章 BAS案例 4.1 多杆机构优化问题", " 第 4 章 BAS案例 4.1 多杆机构优化问题 由莫小娟同学提供案例，尚待补全 图 4.1: 多杆机构优化 "],
["updates.html", "第 5 章 更新及维护计划 5.1 待加入的功能 5.2 联系方式", " 第 5 章 更新及维护计划 5.1 待加入的功能 算法: 加入BSAS 加入BSAS-WPT 加入binary BAS (阮月) 加入二阶 BAS (李晓晓) add BSO(Beetle Swarm Optimizaiton) (王甜甜) … 应用: 工程应用: 多杆件机构优化 建筑系统阻容模型辨识 装配路径规划 批量问题(binary BAS) … 基准测试 计划超过20个基准测试 … 用户界面: 基本界面 基本的shiny界面 更新了约束处理功能 … 自动文档 基于rmarkdown的自动文档报告生成 文档导出 … 算法部分与用户界面将会在rBAS包中不断更新。应用方面虽然有计划，但是除却基准测试外，更多的需要各位同学们的贡献。这部分暂时会选择几个重要的应用集成在rBAS包的案例库中，全部内容则会在本手册中更新。 5.2 联系方式 大家可以加入QQ群(437958608)来讨论涉及BAS算法的各种问题。 更进一步，如果大家有意愿将自己的研究纳入rBAS包或者是手册的应用案例上，欢迎大家给我发送邮件(jywang2016@hust.edu.cn)或者群内私信。具体的代码（如果大家愿意开源的话）或者文档形式（没有代码也是十分欢迎的）都可以具体商议。我也会尽量尝试将大家的matlab或者python代码复现为R，所以“语言阻碍”暂时还不是问题。 如果对rBAS有什么建议，或者bugs，欢迎大家在issues上发表评论。 "],
["e7bb93e8afad.html", "结语", " 结语 暂无 "],
["references.html", "参考文献", " 参考文献 "]
]
